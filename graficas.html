<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MiAlmanake — Gráficas</title>
    <meta name="description" content="Cuadro de mando dinámico con histórico de emociones" />
    <link rel="stylesheet" href="css/styles.css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Cabecera en blanco para fondo oscuro */
      .site-header .brand { color: #ffffff !important; }
      .site-header .brand:hover { color: #1c007a !important; }
      .site-nav a { color: #ffffff !important; }
      .site-nav a:hover { color: #1c007a !important; }
      /* Mantener tipografía del héroe según tema base */
      /* Oculta enlace sobrante para igualar navegación a emociones.html */
      .site-nav a[href="#"] { display: none !important; }
    </style>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="brand" href="index.html">MiAlmanake</a>
        <nav class="site-nav" aria-label="Principal">
          <ul>
            <li><a href="index.html#inicio">Inicio</a></li>
            <li><a href="index.html#caracteristicas">Características</a></li>
            <li><a href="index.html#contacto">Contacto</a></li>
            <li><a href="#">Gráficas</a></li>
          </ul>
        </nav>
      </div>
    </header>

    <main id="graficas" class="section">
      <section class="hero">
        <div class="container">
          <h1>Cuadro de Mando de Emociones</h1>
          <p>Distribución acumulada y filtros por periodo. Datos locales.</p>
        </div>
      </section>

      <section>
        <div class="container">
          <div id="app"></div>
          <noscript>Esta página requiere JavaScript para funcionar.</noscript>
        </div>
      </section>
    </main>

    <footer class="site-footer">
      <div class="container">
        <p>© <span id="year"></span> MiAlmanake. Todos los derechos reservados.</p>
      </div>
    </footer>

    <!-- React + ReactDOM (UMD) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <!-- Babel para JSX en navegador (simple para esta página) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useEffect, useMemo, useState } = React;

      // Config clave de almacenamiento compartida con emociones.html
      const STORAGE_KEY = 'moodCalendar.v1';

      // Colores por emoción (mismo orden que emociones.html)
      const MOOD_COLORS = [
        { name: 'Miedo',        color: '#7e22ce' }, // Morado
        { name: 'Amor propio',  color: '#22c55e' }, // Verde
        { name: 'Tristeza',     color: '#3b82f6' }, // Azul
        { name: 'Amor',         color: '#f97316' }, // Naranja
        { name: 'Enfado',       color: '#ef4444' }, // Rojo
        { name: 'Alegría',      color: '#eab308' }, // Amarillo
      ];

      // Utilidades de color para contraste de texto
      function getContrastText(hex) {
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!m) return '#111827';
        const r = parseInt(m[1], 16) / 255;
        const g = parseInt(m[2], 16) / 255;
        const b = parseInt(m[3], 16) / 255;
        const srgb = [r, g, b].map(v => (v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4)));
        const L = 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
        return L > 0.5 ? '#111827' : '#ffffff';
      }

      // Paleta para Áreas de Vida (vínculos) — colores vivos y contrastados
      const VINCULO_PALETTE = [
        '#0ea5e9', '#3b82f6', '#1d4ed8', '#8b5cf6', '#7c3aed', '#a78bfa',
        '#22c55e', '#16a34a', '#10b981', '#059669', '#14b8a6', '#06b6d4'
      ];
      function stringHash(s) {
        let h = 5381; for (let i = 0; i < s.length; i++) h = ((h << 5) + h) + s.charCodeAt(i);
        return h >>> 0;
      }
      function colorForVinc(name) {
        if (!name) return '#9ca3af';
        const idx = stringHash(name) % VINCULO_PALETTE.length;
        return VINCULO_PALETTE[idx];
      }

      // Normaliza a un único registro por día
      function normalizeToSingle(list) {
        if (!Array.isArray(list) || list.length === 0) return [];
        return [list[0]];
      }

      // Carga datos desde localStorage
      function useMoodData() {
        const [data, setData] = useState({}); // { YYYY-MM-DD: [record] }
        useEffect(() => {
          try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            const normalized = Object.fromEntries(
              Object.entries(parsed).map(([k, v]) => [k, normalizeToSingle(v)])
            );
            setData(normalized);
          } catch (e) {
            console.warn('[graficas] error cargando datos', e);
          }
        }, []);

        // Auto-actualiza si cambia desde otra pestaña
        useEffect(() => {
          const onStorage = (e) => {
            if (e.key === STORAGE_KEY) {
              try {
                const parsed = e.newValue ? JSON.parse(e.newValue) : {};
                const normalized = Object.fromEntries(
                  Object.entries(parsed).map(([k, v]) => [k, normalizeToSingle(v)])
                );
                setData(normalized);
              } catch {}
            }
          };
          window.addEventListener('storage', onStorage);
          return () => window.removeEventListener('storage', onStorage);
        }, []);

        return data;
      }

      function parseDateKey(k) {
        const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(k);
        if (!m) return null;
        return new Date(parseInt(m[1],10), parseInt(m[2],10)-1, parseInt(m[3],10));
      }

      function humanDate(d) {
        if (!d) return '';
        return new Intl.DateTimeFormat('es-ES', { day: '2-digit', month:'long', year:'numeric' }).format(d);
      }

      function Dashboard() {
        const data = useMoodData();

        // Rango temporal
        const [range, setRange] = useState('all'); // all | thisYear | last90 | custom
        const [from, setFrom] = useState(''); // YYYY-MM-DD
        const [to, setTo] = useState('');   // YYYY-MM-DD

        // Derivar min/max
        const keys = useMemo(() => Object.keys(data).filter(k => Array.isArray(data[k])), [data]);
        const [minDate, maxDate] = useMemo(() => {
          if (keys.length === 0) return [null, null];
          const dates = keys.map(parseDateKey).filter(Boolean).sort((a,b)=>a-b);
          return [dates[0] || null, dates[dates.length-1] || null];
        }, [keys]);

        // Determina filtro por rango
        const filterFn = useMemo(() => {
          const now = new Date();
          if (range === 'thisYear') {
            const start = new Date(now.getFullYear(), 0, 1);
            return (d) => d >= start && d <= now;
          }
          if (range === 'last90') {
            const start = new Date(); start.setDate(start.getDate()-90);
            return (d) => d >= start && d <= now;
          }
          if (range === 'custom' && from && to) {
            const s = parseDateKey(from); const e = parseDateKey(to);
            if (s && e) return (d) => d >= s && d <= e;
          }
          return () => true; // all
        }, [range, from, to]);

        // Conteo acumulado por emoción (color)
        const counts = useMemo(() => {
          const map = new Map(); // color -> count
          for (const k of keys) {
            const d = parseDateKey(k); if (!d || !filterFn(d)) continue;
            const rec = data[k]?.[0];
            const color = rec?.color;
            if (color) map.set(color, (map.get(color) || 0) + 1);
          }
          // Devuelve arreglo con metadata de nombre
          const arr = MOOD_COLORS.map(m => ({ ...m, count: map.get(m.color) || 0 }));
          const total = arr.reduce((s,x)=>s+x.count,0);
          return { arr, total };
        }, [data, keys, filterFn]);

        const nonZero = counts.arr.filter(x => x.count > 0);
        const hasData = counts.total > 0;

        // Conteo acumulado por Área de Vida (vínculo)
        const vincAgg = useMemo(() => {
          const map = new Map(); // nombre -> count
          for (const k of keys) {
            const d = parseDateKey(k); if (!d || !filterFn(d)) continue;
            const rec = data[k]?.[0];
            const name = rec?.vinculo?.trim();
            if (name) map.set(name, (map.get(name) || 0) + 1);
          }
          const arr = Array.from(map.entries()).map(([name, count]) => ({ name, count }));
          arr.sort((a,b) => (b.count - a.count) || a.name.localeCompare(b.name));
          const total = arr.reduce((s,x)=>s+x.count,0);
          // Limitar a top-N para legibilidad; agrupar resto como "Otros"
          const N = 10;
          let items = arr;
          if (arr.length > N) {
            const top = arr.slice(0, N);
            const rest = arr.slice(N);
            const restSum = rest.reduce((s,x)=>s+x.count,0);
            if (restSum > 0) top.push({ name: 'Otros', count: restSum, other: true });
            items = top;
          }
          // Añadir color
          const colored = items.map(x => ({ name: x.name, value: x.count, color: x.other ? '#9ca3af' : colorForVinc(x.name) }));
          return { items: colored, total };
        }, [data, keys, filterFn]);

        // Treemap genérico (squarify simplificado)
        function TreemapChart({ items, total }) {
          const ref = React.useRef(null);
          const [size, setSize] = useState({ w: 800, h: 420 });

          useEffect(() => {
            function measure() {
              const el = ref.current; if (!el) return;
              const w = el.clientWidth || 800;
              const h = Math.max(280, Math.round(w * 0.45));
              setSize({ w, h });
            }
            measure();
            window.addEventListener('resize', measure);
            return () => window.removeEventListener('resize', measure);
          }, []);

          const layout = useMemo(() => {
            if (!items || !items.length || !total) return [];
            const W = size.w, H = size.h;
            const scale = (W * H) / (total || 1);
            const areas = items.map(it => ({ it, area: Math.max(0, it.value * scale) }));

            function sumArea(list) { return list.reduce((s, x) => s + x.area, 0); }
            function worstAspect(row, shortSide) {
              const S = sumArea(row);
              const side = shortSide || 1;
              const rowThickness = S / side; // altura de fila si shortSide es el ancho disponible de la fila
              let worst = 0;
              for (const r of row) {
                const otherSide = r.area / rowThickness; // ancho del rectángulo dentro de la fila
                const ratio = otherSide > 0 && rowThickness > 0 ? Math.max(otherSide / rowThickness, rowThickness / otherSide) : Infinity;
                if (ratio > worst) worst = ratio;
              }
              return worst || Infinity;
            }
            const rects = [];
            let x = 0, y = 0, w = W, h = H;
            let remaining = areas.slice().sort((a, b) => b.area - a.area);
            let row = [];

            function layoutRow(rowList) {
              if (rowList.length === 0) return;
              const S = sumArea(rowList);
              if (w <= h) {
                // Fila horizontal (apilada verticalmente)
                const rowH = S / (w || 1);
                let xx = x;
                for (const r of rowList) {
                  const rw = (r.area / (rowH || 1));
                  rects.push({ x: xx, y, w: rw, h: rowH, it: r.it });
                  xx += rw;
                }
                y += rowH; h -= rowH;
              } else {
                // Columna vertical (apilada horizontalmente)
                const colW = S / (h || 1);
                let yy = y;
                for (const r of rowList) {
                  const rh = (r.area / (colW || 1));
                  rects.push({ x, y: yy, w: colW, h: rh, it: r.it });
                  yy += rh;
                }
                x += colW; w -= colW;
              }
            }

            while (remaining.length > 0) {
              const c = remaining[0];
              if (row.length === 0) { row.push(c); remaining.shift(); continue; }
              const short = Math.min(w, h) || 1;
              const current = worstAspect(row, short);
              const next = worstAspect(row.concat([c]), short);
              if (next <= current) {
                row.push(c); remaining.shift();
              } else {
                layoutRow(row); row = [];
              }
            }
            if (row.length) layoutRow(row);
            return rects;
          }, [items, total, size]);

          if (!items || !items.length || !total) {
            return <div className="p-6 text-center text-slate-500">Sin datos en el rango seleccionado</div>;
          }

          return (
            <div className="w-full">
              <div ref={ref} className="relative w-full overflow-hidden rounded-xl shadow-sm ring-1 ring-slate-200" style={{ height: `${size.h}px` }} role="img" aria-label="Mapa proporcional de emociones">
                {layout.map((r, idx) => {
                  const pct = (r.it.value / (total || 1)) * 100;
                  const text = getContrastText(r.it.color);
                  const area = r.w * r.h;
                  const showLabel = area >= 1800; // umbral para legibilidad
                  return (
                    <div key={idx}
                         title={`${r.it.name}: ${r.it.value} (${pct.toFixed(1)}%)`}
                         className="absolute flex items-center justify-center"
                         style={{ left: r.x, top: r.y, width: r.w, height: r.h, background: r.it.color, color: text }}>
                      {showLabel ? (
                        <div className="px-2 text-sm font-medium drop-shadow-sm" style={{ textAlign: 'center' }}>
                          {r.it.name}
                          <span className="ml-1 opacity-90">{pct.toFixed(0)}%</span>
                        </div>
                      ) : null}
                    </div>
                  );
                })}
              </div>

              {/* La leyenda se gestiona fuera para cada caso */}
            </div>
          );
        }

        return (
          <div className="mx-auto max-w-6xl">
            {/* Filtros */}
            <div className="mb-4 flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
              <div className="flex flex-wrap items-center gap-2">
                <label className={`btn ${range==='all'?'primary':''}`}> 
                  <input type="radio" name="r" className="hidden" checked={range==='all'} onChange={()=>setRange('all')} />Todo
                </label>
                <label className={`btn ${range==='thisYear'?'primary':''}`}>
                  <input type="radio" name="r" className="hidden" checked={range==='thisYear'} onChange={()=>setRange('thisYear')} />Este año
                </label>
                <label className={`btn ${range==='last90'?'primary':''}`}>
                  <input type="radio" name="r" className="hidden" checked={range==='last90'} onChange={()=>setRange('last90')} />Últimos 90 días
                </label>
                <label className={`btn ${range==='custom'?'primary':''}`}>
                  <input type="radio" name="r" className="hidden" checked={range==='custom'} onChange={()=>setRange('custom')} />Personalizado
                </label>
              </div>
              {range === 'custom' && (
                <div className="flex items-center gap-2">
                  <input type="date" className="rounded border border-slate-300 px-2 py-1" value={from} onChange={(e)=>setFrom(e.target.value)} />
                  <span>—</span>
                  <input type="date" className="rounded border border-slate-300 px-2 py-1" value={to} onChange={(e)=>setTo(e.target.value)} />
                </div>
              )}
            </div>

            {/* KPIs */}
            <div className="mb-6 grid grid-cols-1 gap-3 sm:grid-cols-2 lg:grid-cols-4">
              <div className="rounded-xl border border-slate-200 bg-white p-4">
                <div className="text-xs text-slate-500">Registros en rango</div>
                <div className="text-2xl font-semibold">{counts.total}</div>
              </div>
              <div className="rounded-xl border border-slate-200 bg-white p-4">
                <div className="text-xs text-slate-500">Desde</div>
                <div className="text-sm">{humanDate(minDate) || '—'}</div>
              </div>
              <div className="rounded-xl border border-slate-200 bg-white p-4">
                <div className="text-xs text-slate-500">Hasta</div>
                <div className="text-sm">{humanDate(maxDate) || '—'}</div>
              </div>
              <div className="rounded-xl border border-slate-200 bg-white p-4">
                <div className="text-xs text-slate-500">Emociones presentes</div>
                <div className="text-2xl font-semibold">{counts.arr.filter(x=>x.count>0).length}</div>
              </div>
            </div>

            {/* Dos treemaps lado a lado en pantallas grandes */}
            <div className="grid grid-cols-1 gap-4 lg:grid-cols-2">
              <div className="rounded-2xl border border-slate-200 bg-white p-4">
                <div className="mb-3 text-sm font-semibold text-slate-700">Mapa proporcional (treemap) por emoción</div>
                <TreemapChart items={nonZero.map(m => ({ name: m.name, value: m.count, color: m.color }))} total={counts.total} />
                <div className="mt-3 grid grid-cols-2 md:grid-cols-3 gap-2">
                  {counts.arr.map((m) => (
                    <div key={m.color} className="flex items-center justify-between rounded-lg border border-slate-200 bg-white px-2 py-1 text-sm">
                      <div className="flex items-center gap-2">
                        <span className="inline-block h-3 w-3 rounded" style={{ background: m.color }} />
                        <span className="text-slate-700">{m.name}</span>
                      </div>
                      <span className="font-mono text-slate-800">{m.count}</span>
                    </div>
                  ))}
                </div>
              </div>

              <div className="rounded-2xl border border-slate-200 bg-white p-4">
                <div className="mb-3 text-sm font-semibold text-slate-700">Mapa proporcional (treemap) por área de vida</div>
                <TreemapChart items={vincAgg.items} total={vincAgg.total} />
                <div className="mt-3 grid grid-cols-2 md:grid-cols-3 gap-2">
                  {vincAgg.items.map((v) => (
                    <div key={v.name} className="flex items-center justify-between rounded-lg border border-slate-200 bg-white px-2 py-1 text-sm">
                      <div className="flex items-center gap-2">
                        <span className="inline-block h-3 w-3 rounded" style={{ background: v.color }} />
                        <span className="text-slate-700">{v.name}</span>
                      </div>
                      <span className="font-mono text-slate-800">{v.value}</span>
                    </div>
                  ))}
                </div>
              </div>
            </div>

            <div className="mx-auto mt-6 text-center text-xs text-slate-500">
              Gráfico de rectángulos · Datos locales (localStorage) · Actualiza en vivo al cambiar en Emociones
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('app'));
      root.render(<Dashboard />);
    </script>

    <script src="js/main.js" defer></script>
  </body>
  </html>
